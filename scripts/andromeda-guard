#!/bin/bash
#
# A minimal script to manage the Phosh OSK using gsettings.
# It performs an initial reset and can be triggered again via a
# custom DBus signal.

# ==============================================================================
# SECTION 1: CORE HELPER FUNCTIONS
# ==============================================================================

# Shows a countdown notification at 5-second intervals.
# All notifications are timed to expire when the countdown finishes.
# Arguments:
#   $1: The total number of seconds for the countdown.
notify_with_countdown() {
    local seconds_total=$1
    # Loop from the total number of seconds down to 1.
    for (( i=seconds_total; i>0; i-- )); do
        # We only send a notification if the current second is a multiple of 5,
        # or if it's the very first second of the countdown.
        if (( i % 5 == 0 || i == seconds_total )); then
            # The expire time is the remaining number of seconds in milliseconds.
            # This ensures all notifications disappear when the countdown reaches zero.
            local timeout_ms=$((i * 1000))
            notify-send --icon="input-keyboard" --hint=int:transient:1 --expire-time="$timeout_ms" --app-name="Andromeda display guard" \
                "OSK locked for $i seconds"
        fi
        sleep 1
    done
}

# Enables the on-screen keyboard via gsettings and sends a notification.
enable_keyboard() {
    gsettings set org.gnome.desktop.a11y.applications screen-keyboard-enabled true
    notify-send --icon="input-keyboard" --expire-time=3000 --hint=int:transient:1 --app-name="Andromeda display guard" "Andromeda is ready - OSK Unlocked"
}

# Disables the on-screen keyboard via gsettings and sends a notification.
disable_keyboard() {
    gsettings set org.gnome.desktop.a11y.applications screen-keyboard-enabled false
}

# Handles a custom session event to perform a "hard reset" on the OSK.
handle_session_reset() {
    disable_keyboard
    notify_with_countdown "20"
    enable_keyboard
}

# ==============================================================================
# SECTION 2: MONITORING FUNCTION
# This runs in the background after the initial setup.
# ==============================================================================

# This function silently monitors for Andromeda session start/stop and triggers the commands
monitor_andromeda_reset() {
    # The command for your main script that handles the mounting/unmounting
    local SHARE_SCRIPT_CMD="andromeda-shared-folders"

    # Monitor for both NameAcquired (start) and NameLost (stop) signals
    dbus-monitor --session "type='signal',interface='org.freedesktop.DBus',member='NameAcquired,NameLost'" | \
    while IFS= read -r line; do
        # We only care about lines that contain the specific Andromeda session name
        if [[ "$line" != *"io.furios.Andromeda.Session"* ]]; then
            continue
        fi
        
        # Check if the signal is for the session STARTING
        if [[ "$line" == *"member=NameAcquired"* ]]; then
        handle_session_reset
            # Wait 20 seconds, then run the start command in the background
            (
                sleep 20
                ${SHARE_SCRIPT_CMD} start
            ) &
        
        # Check if the signal is for the session STOPPING
        elif [[ "$line" == *"member=NameLost"* ]]; then
            # Run the stop command immediately in the background
            (
                ${SHARE_SCRIPT_CMD} stop
            ) &
        fi
    done
}

# ==============================================================================
# SECTION 3: SCRIPT ENTRYPOINT
# ==============================================================================

main() {

local SHARE_SCRIPT_CMD="andromeda-shared-folders"
    # --- Step 1: Initial Setup ---
    # This sequence runs once when the script starts after a user logs in.
    # It ensures the keyboard starts in a known, clean state.
    andromeda session start &
    disable_keyboard
    notify_with_countdown "40"
    enable_keyboard
    ${SHARE_SCRIPT_CMD} start

    # --- Step 2: Start Persistent Monitoring ---
    # After the setup, the reset monitor runs in the background for the rest of the session.
    monitor_andromeda_reset &

    # Wait for all background processes to complete, which will be when the script is terminated.
    wait
}

# When the script is told to exit (e.g., via Ctrl+C or on logout),
# kill all background processes started by it.
trap "pkill -P $$; exit" SIGINT SIGTERM

# Run the main function to start the script.
main

