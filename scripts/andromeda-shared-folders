#!/bin/bash

# A script to manage permanent, two-way, ACL-permissioned folder shares
# between a Linux host and an Andromeda (Android) environment.
# This script is intended to be run as root (e.g., using 'sudo' or 'pkexec').

# --- Configuration ---

# Robustly determine the original non-root user who launched the script
if [ -n "$PKEXEC_UID" ]; then
    HOST_USER=$(getent passwd "$PKEXEC_UID" | cut -d: -f1)
elif [ -n "$SUDO_USER" ]; then
    HOST_USER="$SUDO_USER"
else
    # Allow running as root directly if a user is specified via an env var
    if [ "$(id -u)" -eq 0 ] && [ -n "$TARGET_USER" ]; then
        HOST_USER="$TARGET_USER"
    else
        echo "ERROR: Could not determine the original user. Please run with 'sudo' or 'pkexec'." >&2
        echo "Alternatively, as root, run: TARGET_USER=username $0 <command>" >&2
        exit 1
    fi
fi

HOST_HOME=$(getent passwd "$HOST_USER" | cut -d: -f6)
ANDROID_UID=1023 # Standard Waydroid/Anbox user ID
PID_FILE="/run/user/$(id -u "$HOST_USER")/andromeda_permission_guardian.pid" # Store PID in user's runtime dir

# --- Source and Target Locations ---
ANDROID_STORAGE_SOURCE="${HOST_HOME}/.local/share/andromeda/data/media/0"
# Where Linux folders will be mounted *inside* Android.
LINUX_MOUNT_BASE="${ANDROID_STORAGE_SOURCE}/Linux-Share"
# Where Android folders will be mounted *on* the Linux host.
ANDROID_MOUNT_BASE="${HOST_HOME}/Android-Share"

# --- Folders to Exclude from Mounting (case-sensitive folder names) ---
LINUX_EXCLUDE_FOLDERS=( "Android" "Android-Share" )
ANDROID_EXCLUDE_FOLDERS=( "Host" "Linux-Share" )

# --- fstab Management ---
FSTAB_MARKER_BEGIN="# BEGIN ANDROMEDA MOUNTS"
FSTAB_MARKER_END="# END ANDROMEDA MOUNTS"

# --- Style and Helpers ---
C_GREEN="\033[1;32m"; C_YELLOW="\033[1;33m"; C_RED="\033[1;31m"; C_RESET="\033[0m"
log() { echo -e "${C_GREEN}[ANDROMEDA]${C_RESET} $1"; }
warn() { echo -e "${C_YELLOW}[WARNING]${C_RESET} $1"; }
error() { echo -e "${C_RED}[ERROR]${C_RESET} $1" >&2; }

# --- Helper Functions ---
is_excluded() {
    local item=$1; shift; local list=("$@")
    for excluded in "${list[@]}"; do
        if [[ "$item" == "$excluded" ]]; then return 0; fi # 0 for true (found)
    done
    return 1 # 1 for false
}

# --- Core Functions ---

## Mount Command
do_mount() {
    log "--- Mounting Shared Folders ---"
    
    # Ensure a clean state before starting
    log "Ensuring previous mounts are cleared..."
    do_unmount >/dev/null 2>&1

    local fstab_entries=()

    # --- Step 1: Mount Linux home folders into Android ---
    log "Processing Linux -> Android mounts..."
    mkdir -p "$LINUX_MOUNT_BASE"
    chown "${ANDROID_UID}:${ANDROID_UID}" "$LINUX_MOUNT_BASE"
    chmod 775 "$LINUX_MOUNT_BASE"

    # Find and mount all non-hidden directories from HOST_HOME
    while IFS= read -r source_path; do
        local dir_name=$(basename "$source_path")
        
        if is_excluded "$dir_name" "${LINUX_EXCLUDE_FOLDERS[@]}"; then
            log "  -> Skipping excluded Linux directory: ${C_YELLOW}${dir_name}${C_RESET}"
            continue
        fi

        local target_path="${LINUX_MOUNT_BASE}/${dir_name}"
        log "  -> Mounting ${C_GREEN}${dir_name}${C_RESET}..."
        mkdir -p "$target_path"
        chown "${ANDROID_UID}:${ANDROID_UID}" "$target_path"
        chmod 775 "$target_path"
        
        if ! mount --bind "$source_path" "$target_path"; then
            error "Failed to mount $dir_name. Skipping."
            rmdir "$target_path"
            continue
        fi
        
        fstab_entries+=("$source_path $target_path none bind 0 0")

    done < <(find "$HOST_HOME" -maxdepth 1 -mindepth 1 -type d ! -name ".*")

    # --- Step 2: Mount Android folders into Linux ---
    log "Processing Android -> Linux mounts..."
    su -c "mkdir -p '$ANDROID_MOUNT_BASE'" "$HOST_USER"
    chmod 775 "$ANDROID_MOUNT_BASE"

    while IFS= read -r source_path; do
        local dir_name=$(basename "$source_path")

        if is_excluded "$dir_name" "${ANDROID_EXCLUDE_FOLDERS[@]}"; then
            log "  -> Skipping excluded Android directory: ${C_YELLOW}${dir_name}${C_RESET}"
            continue
        fi

        local target_path="${ANDROID_MOUNT_BASE}/${dir_name}"
        log "  -> Mounting ${C_GREEN}${dir_name}${C_RESET}..."
        su -c "mkdir -p '$target_path'" "$HOST_USER"
        chmod 775 "$target_path"
        
        if ! mount --bind "$source_path" "$target_path"; then
            error "Failed to mount $dir_name. Skipping."
            su -c "rmdir '$target_path'" "$HOST_USER"
            continue
        fi

        fstab_entries+=("$source_path $target_path none bind 0 0")
        
    done < <(find "$ANDROID_STORAGE_SOURCE" -maxdepth 1 -mindepth 1 -type d ! -name ".*")

    # --- Step 3: Update /etc/fstab ---
    if [ ${#fstab_entries[@]} -gt 0 ]; then
        log "Updating /etc/fstab for persistent mounts..."
        sed -i.andromeda.bak "/${FSTAB_MARKER_BEGIN}/,/${FSTAB_MARKER_END}/d" /etc/fstab

        {
            echo "${FSTAB_MARKER_BEGIN}"
            printf '%s\n' "${fstab_entries[@]}"
            echo "${FSTAB_MARKER_END}"
        } >> /etc/fstab
        log "fstab updated successfully."
    else
        warn "No valid mount points found. /etc/fstab was not modified."
    fi
    
    log "--- Mount Setup Complete ---"
}

## Unmount Command
do_unmount() {
    log "--- Unmounting All Shared Folders ---"
    
    mount | grep -E "(${LINUX_MOUNT_BASE}|${ANDROID_MOUNT_BASE})" | awk '{print $3}' | sort -r | while IFS= read -r mount_point; do
        log "  -> Unmounting ${C_YELLOW}${mount_point}${C_RESET}"
        umount "$mount_point" || umount -l "$mount_point"
    done

    log "Cleaning up base mount directories..."
    rmdir "$ANDROID_MOUNT_BASE" &>/dev/null || warn "Could not remove ${ANDROID_MOUNT_BASE}. It might not be empty."
    rmdir "$LINUX_MOUNT_BASE" &>/dev/null || warn "Could not remove ${LINUX_MOUNT_BASE}. It might not be empty."

    if [ -f /etc/fstab ] && grep -q "$FSTAB_MARKER_BEGIN" /etc/fstab; then
        log "Removing entries from /etc/fstab..."
        sed -i.andromeda.bak "/${FSTAB_MARKER_BEGIN}/,/${FSTAB_MARKER_END}/d" /etc/fstab
        log "fstab cleaned."
    fi

    log "--- Unmount Complete ---"
}

## Permission Guard Commands
run_permission_guardian() {
    log "Permissions Guardian: Starting..."
    local watch_dirs=()

    # Discover Linux source directories to watch
    while IFS= read -r source_path; do
        local dir_name=$(basename "$source_path")
        if ! is_excluded "$dir_name" "${LINUX_EXCLUDE_FOLDERS[@]}"; then
            [ -d "$source_path" ] && watch_dirs+=("$source_path")
        fi
    done < <(find "$HOST_HOME" -maxdepth 1 -mindepth 1 -type d ! -name ".*")
    
    # Add the Android mount base to the watch list
    [ -d "$ANDROID_MOUNT_BASE" ] && watch_dirs+=("$ANDROID_MOUNT_BASE")
    
    log "Permissions Guardian: Performing initial permission sync..."
    # Apply ACLs to all watched directories recursively
    for dir in "${watch_dirs[@]}"; do
        log "  -> Applying ACLs to ${C_GREEN}${dir}${C_RESET}..."
        setfacl -Rn -m u:${HOST_USER}:rwx,d:u:${HOST_USER}:rwx,u:${ANDROID_UID}:rwx,d:u:${ANDROID_UID}:rwx "$dir"
    done
    
    log "Permissions Guardian: Initial sync complete. Monitoring for new files..."
    
    inotifywait -m -r -q -e create -e moved_to --format '%w%f' "${watch_dirs[@]}" | while read -r NEW_FILE_PATH; do
        log "Permissions Guardian: New item: ${NEW_FILE_PATH}"
        setfacl -m u:${HOST_USER}:rwx,u:${ANDROID_UID}:rwx "${NEW_FILE_PATH}"
        log "Permissions Guardian: Permissions fixed."
    done
}

do_start_permission_guard() {
    wait_for_keyring_unlock
    sleep 5
    
    log "--- Starting Permissions Guardian ---"
    do_stop_permission_guard >/dev/null 2>&1

    # Check if mounts are active before starting
    if ! findmnt -n --target "$ANDROID_MOUNT_BASE" >/dev/null; then
        error "Mounts not found. '${ANDROID_MOUNT_BASE}' is not an active mount point."
        error "Please run '${0##*/} mount' first."
        exit 1
    fi
    
    log "Mounts detected. Launching guardian in the background..."
    mkdir -p "$(dirname "$PID_FILE")"
    chown "$HOST_USER":"$(id -g "$HOST_USER")" "$(dirname "$PID_FILE")"

    run_permission_guardian &
    echo $! > "$PID_FILE"
    chown "$HOST_USER":"$(id -g "$HOST_USER")" "$PID_FILE"

    log "Permissions Guardian started with PID $(cat "$PID_FILE")."
}

wait_for_keyring_unlock() {
    echo "Waiting for GNOME Keyring to unlock..."
    while gdbus call --session \
        --dest org.freedesktop.secrets \
        --object-path /org/freedesktop/secrets/collection/login \
        --method org.freedesktop.DBus.Properties.Get \
        org.freedesktop.Secret.Collection 'Locked' | grep -q "true"; do
        sleep 1
    done
    echo "Keyring is unlocked!"
}

do_stop_permission_guard() {
    log "--- Stopping Permissions Guardian ---"
    if [ -f "$PID_FILE" ]; then
        local pid_to_kill=$(cat "$PID_FILE")
        if ps -p "$pid_to_kill" > /dev/null; then
            log "Stopping guardian process (PID: ${pid_to_kill})...";
            pkill -P "$pid_to_kill" &>/dev/null
            kill "$pid_to_kill" &>/dev/null
            rm -f "$PID_FILE"
            log "Guardian stopped."
        else
            warn "PID file found, but no process with PID ${pid_to_kill} is running. Cleaning up stale file."
            rm -f "$PID_FILE"
        fi
    else
        log "Guardian is not running (no PID file found)."
    fi
}


# --- Main Execution Logic ---

# Must be run as root
if [[ $(id -u) -ne 0 ]]; then
    error "This script must be run as root. Use 'sudo' or 'pkexec'."
    exit 1
fi

# Check for required commands
for cmd in setfacl inotifywait findmnt; do
    if ! command -v "$cmd" &>/dev/null; then
        error "'$cmd' is not installed. Please install required packages (e.g., 'acl' and 'inotify-tools')."
        exit 1
    fi
done

# Check if we successfully identified the user and their home
if [[ -z "$HOST_USER" || -z "$HOST_HOME" || ! -d "$HOST_HOME" ]]; then
    error "Could not determine a valid user or home directory."
    exit 1
fi

# Check if the Andromeda directory exists
if [[ ! -d "$ANDROID_STORAGE_SOURCE" ]]; then
    error "Andromeda storage not found at: ${ANDROID_STORAGE_SOURCE}"
    error "Is Andromeda (Waydroid/Anbox) installed and has it been started at least once?"
    exit 1
fi

# Command routing
case "$1" in
    mount)
        do_mount
        ;;
    unmount)
        do_unmount
        ;;
    start-permission-guard)
        do_start_permission_guard
        ;;
    stop-permission-guard)
        do_stop_permission_guard
        ;;
    *)
        echo "Usage: ${0##*/} [mount|unmount|start-permission-guard|stop-permission-guard]"
        exit 1
        ;;
esac

exit 0
