#!/bin/bash

# Monitor for incoming calls
monitor() {
    dbus-monitor --system "interface='org.freedesktop.ModemManager1.Modem.Voice',type='signal',member='CallAdded'" |
    while read -r line; do
        if echo "$line" | grep -qE "^signal.*CallAdded"; then
            echo "Call detected. Checking call id..."
            callid
        fi
    done
}

#Monitor callid so we can check phonenumber and call state 
callid() { TIME=$(date +"%H:%M")
	DAY=$(date +"%-d.%-m.")
	VOICECALLID="$(
    output=$(mmcli -m any --voice-list-calls -a)
    number=$(echo "$output" | awk -F'/Call/' '{print $2}' | awk '{print $1}')
    echo $number
)"
phone
}

# Monitor other partys phonenumber
phone() {
	PHONENUMBER="$(mmcli -m any -o "$VOICECALLID" -K | \
		grep call.properties.number | \
		cut -d ':' -f2 | \
		tr -d  ' ')"

    echo "$PHONENUMBER" | wl-copy
		
		direct
}


# Monitor call direction (outgoing or incoming)
direct() {
    # Run the command and get the last line
    last_line=$(mmcli -m any --voice-list-calls | tail -n 1)

    # Check if the second-last word is "outgoing"
    if [[ $(echo "$last_line" | awk '{print $(NF-1)}') == "outgoing" ]]; then
        echo "The call is outgoing. Proceeding with further steps..."
        changes & 
        adjust_volume
    else
        echo "The call is not outgoing. No action taken."
        adjust_volume
    fi
}

adjust_volume() {
    # Variable to store the last known speaker/earpiece mode
    last_speaker_status=""

    while true; do
        # Fetch the output of the command
        mmcli_output=$(mmcli -m any --voice-list-calls)

        # Stop if "No calls were found"
        if echo "$mmcli_output" | grep -q "No calls were found"; then
            echo "Call ended. Stopping volume adjustment."
            break
        else
            # Extract current speaker/earpiece mode
            speaker_status=$(callaudiocli --status | grep "Speaker enabled" | awk '{print $NF}')

            # Check if the mode has changed
            if [[ "$speaker_status" != "$last_speaker_status" ]]; then
                # Find the active call stream index (first sink-input)
                STREAM_INDEX=$(pacmd list-sink-inputs | grep "index:" | head -n 1 | awk '{print $2}')

                if [[ "$speaker_status" == "CALL_AUDIO_SPEAKER_ON" ]]; then
                    echo "Speaker mode detected. Setting volume to 100%..."
                    if [ -n "$STREAM_INDEX" ]; then
                        pactl set-sink-input-volume $STREAM_INDEX 100%
                        echo "Volume set to 100% for speaker mode."
                    fi
                elif [[ "$speaker_status" == "CALL_AUDIO_SPEAKER_OFF" ]]; then
                    echo "Earpiece mode detected. Adjusting to 40% volume..."
                    if [ -n "$STREAM_INDEX" ]; then
                        pactl set-sink-input-volume $STREAM_INDEX 40%
                        echo "Volume set to 40% for earpiece mode."
                    fi
                else
                    echo "Unknown speaker status. Continuing..."
                fi

                # Update the last known status
                last_speaker_status="$speaker_status"
            fi  # End of the 'if' block checking for speaker status change
        fi

        sleep 0.5  # Tight polling interval
    done
}

# Monitor for call changes
changes() {
    feedbackd_profile=$(gsettings get org.sigxcpu.feedbackd profile | tr -d "'")

    while true; do
        # Run the command and get the last line (updated in each loop iteration)
        last_line=$(mmcli -m any --voice-list-calls | tail -n 1)
        status_word=$(echo "$last_line" | awk '{print $NF}' | tr -d '()')

        if [[ "$status_word" == "active" || "$status_word" == "activeaccepted" ]]; then
            echo "The call status is active. Proceeding with further steps..."
            gsettings set org.sigxcpu.feedbackd profile silent
            break  # Exit the loop as the call has been accepted
        elif [[ $(mmcli -m any --voice-list-calls) == *"No calls were found"* ]]; then
            gsettings set org.sigxcpu.feedbackd profile "$feedbackd_profile"
            break
        else
            # Vibrate and blink led if call is not yet active
            cd /sys/class/leds/vibrator && echo 50 > duration && echo 1 > activate
            echo 12 > /sys/class/leds/green/brightness
            sleep 0.5  # Shorter interval for faster vibration response
            echo 0 > /sys/class/leds/green/brightness
        fi
    done

    # Restore profile after exiting the loop
    gsettings set org.sigxcpu.feedbackd profile "$feedbackd_profile"
}

# Main script
monitor