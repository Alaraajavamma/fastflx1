#!/bin/bash

# A script to suspend/kill applications on screen lock and resume them on unlock.
# Runs as a background service.
# Usage: batterysaver {start|stop}

# --- CONFIGURATION & SETUP ---
PID_FILE="/tmp/batterysaver.pid"
SUSPEND_FILE="/tmp/suspended_pids.txt"
# IMPROVEMENT: Exclude apps using their app_id for better reliability
EXCLUDED_APPS=("org.gnome.clocks" "sm.puri.Chatty" "org.gnome.Calls")

# In-memory map for native apps, populated at start
declare -A APP_MAP

# --- FUNCTIONS ---

build_app_map() {
    echo "Building application map..."
    APP_MAP=() # Clear the map
    local desktop_files=$(find /usr/share/applications/ ~/.local/share/applications/ -name "*.desktop" 2>/dev/null)
    for file in $desktop_files; do
        local app_id=$(basename "$file" .desktop)
        local exec_line=$(grep -E '^Exec=' "$file" | head -1)
        if [ -n "$exec_line" ]; then
            local process_name=$(echo "$exec_line" | sed 's/Exec=//' | awk '{print $1}' | xargs basename)
            APP_MAP["$app_id"]="$process_name"
        fi
    done
}

contains_element() {
  local e match="$1"; shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

suspend_and_kill_apps() {
    echo "$(date): Screen locked. Suspending/killing apps..."
    > "$SUSPEND_FILE" # Clear the PID file for the new session
    if ! [ -x "$(command -v wlrctl)" ]; then
        echo "Error: wlrctl not found."; return 1;
    fi

    local android_apps_to_close=()
    # Use process substitution to avoid issues with pipes creating subshells
    while read -r raw_app_id; do
        local app_id=${raw_app_id%:}

        # --- IMPROVEMENT: Exclude apps by app_id at the very beginning ---
        if contains_element "$app_id" "${EXCLUDED_APPS[@]}"; then
            echo "Skipping excluded app: $app_id"
            continue
        fi

        if [[ "$app_id" == android.* ]]; then
            # --- Handle Android App: Collect for Killing ---
            android_apps_to_close+=("$app_id")
        else
            # --- Handle Native Linux App: Suspend ---
            local process_name=${APP_MAP[$app_id]}
            if [ -z "$process_name" ]; then
                process_name="$app_id" # Fallback to using app_id as process name
            fi

            if [ -n "$process_name" ]; then
                # --- IMPROVEMENT: Use pgrep -x for an exact process name match ---
                local pid=$(pgrep -x "$process_name" | head -n 1)
                if [ -n "$pid" ]; then
                    echo "Suspending native process '$process_name' (PID: $pid)"
                    kill -STOP "$pid"
                    echo "$pid" >> "$SUSPEND_FILE"
                fi
            fi
        fi
    done < <(wlrctl window list | awk 'NR>1 {print $1}')

    # Close all collected Android apps at once
    if [ ${#android_apps_to_close[@]} -gt 0 ]; then
        echo "Closing Android apps: ${android_apps_to_close[*]}"
        wlrctl window close "${android_apps_to_close[@]}"
    fi
    echo "Finished suspend/kill process."
}


resume_apps() {
    echo "$(date): Screen unlocked. Resuming apps..."
    if [ -f "$SUSPEND_FILE" ]; then
        while read -r pid; do
            echo "Resuming native process (PID: $pid)"
            kill -CONT "$pid"
        done < "$SUSPEND_FILE"
        > "$SUSPEND_FILE"
    fi
    echo "Finished resuming."
}

main_daemon_loop() {
    # Ensure the suspend file exists
    touch "$SUSPEND_FILE"
    # Build the application map once for this session
    build_app_map

    echo "Monitoring for screen lock/unlock events..."
    dbus-monitor --session "type='signal',interface='org.gnome.ScreenSaver',member='ActiveChanged'" | \
    while read -r line; do
        if echo "$line" | grep -q "boolean true"; then
            suspend_and_kill_apps
        elif echo "$line" | grep -q "boolean false"; then
            resume_apps
        fi
    done
}

start() {
    if [ -f "$PID_FILE" ]; then
        echo "Service is already running (PID: $(cat $PID_FILE))."
        exit 1
    fi
    echo "Starting batterysaver service..."
    # Start the main loop in the background
    main_daemon_loop &
    # Store its PID
    echo $! > "$PID_FILE"
    echo "Service started with PID: $(cat $PID_FILE)."
}

stop() {
    if [ ! -f "$PID_FILE" ]; then
        echo "Service is not running."
        exit 1
    fi
    local pid=$(cat "$PID_FILE")
    echo "Stopping batterysaver service (PID: $pid)..."
    kill "$pid"
    rm "$PID_FILE"
    echo "Service stopped."
}

# --- MAIN EXECUTION ---
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        exit 1
        ;;
esac

exit 0