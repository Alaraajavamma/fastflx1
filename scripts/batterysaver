#!/bin/bash

# A script to suspend/kill applications on screen lock and resume them on unlock.
# Runs as a background service.
# Usage: batterysaver {start|stop}

# --- CONFIGURATION & SETUP ---
PID_FILE="/tmp/batterysaver.pid"
SUSPEND_FILE="/tmp/suspended_pids.txt"
# Exclude apps using their app_id for better reliability
EXCLUDED_APPS=("org.gnome.clocks" "sm.puri.Chatty" "org.gnome.Calls")

# In-memory map for native apps, populated at start
declare -A APP_MAP

# --- FUNCTIONS ---

# build_app_map populates a mapping from desktop file app_id to executable name.
build_app_map() {
    echo "Building application map..."
    APP_MAP=() # Clear the map
    # Set shell option to handle filenames with spaces correctly
    shopt -s nullglob
    local desktop_files=(/usr/share/applications/*.desktop ~/.local/share/applications/*.desktop)
    shopt -u nullglob

    for file in "${desktop_files[@]}"; do
        local app_id=$(basename "$file" .desktop)
        local exec_line=$(grep -E '^Exec=' "$file" | head -1)
        if [ -n "$exec_line" ]; then
            local process_name=$(echo "$exec_line" | sed 's/Exec=//' | awk '{print $1}' | xargs basename)
            APP_MAP["$app_id"]="$process_name"
        fi
    done
}

# contains_element checks if an element exists in an array.
contains_element() {
  local e match="$1"; shift
  for e; do [[ "$e" == "$match" ]] && return 0; done
  return 1
}

# suspend_and_kill_apps is the core function called on screen lock.
suspend_and_kill_apps() {
    echo "$(date): Screen locked. Suspending/killing apps..."
    > "$SUSPEND_FILE"
    if ! [ -x "$(command -v wlrctl)" ]; then
        echo "Error: wlrctl command not found. Is it installed and in your PATH?"
        return 1
    fi

    while read -r raw_app_id_line; do
        # Clean the app_id string by removing the trailing colon and any other whitespace.
        local app_id
        app_id=$(echo "$raw_app_id_line" | sed 's/[:[:space:][:cntrl:]]//g')

        if [ -z "$app_id" ]; then
            continue # Skip empty lines
        fi

        if contains_element "$app_id" "${EXCLUDED_APPS[@]}"; then
            echo "Skipping excluded app: $app_id"
            continue
        fi

        # Make the check case-insensitive to match 'android.', 'Android.', etc.
        if [[ "${app_id,,}" == android.* ]]; then
            echo "Found Android app '$app_id', attempting to close."
            if ! timeout 2s wlrctl window close "$app_id"; then
                echo "Warning: Failed to close Android app '$app_id'. It may be unresponsive or already closed."
            fi
        else
            # Handle Native Linux App by suspending it
            local process_name=${APP_MAP[$app_id]}
            if [ -z "$process_name" ]; then
                process_name="$app_id"
            fi

            if [ -n "$process_name" ]; then
                # Find all PIDs for the process and suspend them
                local pids=$(pgrep -f "\b$process_name\b")
                for pid in $pids; do
                    if [ -n "$pid" ]; then
                        echo "Suspending native process '$process_name' (PID: $pid)"
                        kill -STOP "$pid"
                        echo "$pid" >> "$SUSPEND_FILE"
                    fi
                done
            fi
        fi
    done < <(wlrctl window list | awk '{print $1}')

    # --- MODIFICATION START: Special handling for Firefox ---
    echo "Performing special check for Firefox process..."
    # Find all PIDs for processes whose command line contains the word 'firefox'
    local firefox_pids
    firefox_pids=$(pgrep -f "\bfirefox\b")

    if [ -n "$firefox_pids" ]; then
        for pid in $firefox_pids; do
            # Check if this PID was already suspended by the wlrctl loop above
            if ! grep -q "^${pid}$" "$SUSPEND_FILE"; then
                echo "Suspending Firefox process (PID: $pid) not found in window list."
                if kill -STOP "$pid"; then
                    echo "$pid" >> "$SUSPEND_FILE"
                else
                    echo "Warning: Failed to suspend Firefox PID $pid."
                fi
            else
                echo "Firefox process (PID: $pid) was already handled via window list."
            fi
        done
    else
        echo "No running Firefox process found."
    fi
    # --- MODIFICATION END ---

    echo "Finished suspend/kill process."
}

# resume_apps is called on screen unlock.
resume_apps() {
    echo "$(date): Screen unlocked. Resuming apps..."
    if [ -f "$SUSPEND_FILE" ]; then
        while read -r pid; do
            if ps -p "$pid" > /dev/null; then
                echo "Resuming native process (PID: $pid)"
                kill -CONT "$pid"
            else
                echo "Process with PID $pid no longer exists. Skipping."
            fi
        done < "$SUSPEND_FILE"
        > "$SUSPEND_FILE"
    fi
    echo "Finished resuming."
}

# main_daemon_loop monitors D-Bus for screen lock/unlock signals.
main_daemon_loop() {
    >"$SUSPEND_FILE"
    build_app_map

    echo "Monitoring for screen lock/unlock events..."
    dbus-monitor --session "type='signal',interface='org.gnome.ScreenSaver',member='ActiveChanged'" | \
    while read -r line; do
        if echo "$line" | grep -q "boolean true"; then
            suspend_and_kill_apps
        elif echo "$line" | grep -q "boolean false"; then
            resume_apps
        fi
    done
}

# start launches the main loop as a background daemon process.
start() {
    if [ -f "$PID_FILE" ]; then
        echo "Service is already running (PID: $(cat $PID_FILE))."
        exit 1
    fi
    echo "Starting batterysaver service..."
    main_daemon_loop &
    echo $! > "$PID_FILE"
    echo "Service started with PID: $(cat $PID_FILE)."
}

# stop kills the background daemon process.
stop() {
    if [ ! -f "$PID_FILE" ]; then
        echo "Service is not running."
        exit 1
    fi
    local pid=$(cat "$PID_FILE")
    echo "Stopping batterysaver service (PID: $pid)..."
    
    # --- FIX: Check if the process exists before trying to kill it ---
    if ps -p "$pid" > /dev/null; then
        # Kill the process group to ensure child processes are also terminated
        kill -- -"$pid"
        echo "Service stopped."
    else
        echo "Service was already stopped (process with PID $pid not found)."
    fi

    # Always remove the PID file
    rm "$PID_FILE"
}

# --- MAIN EXECUTION ---
case "$1" in
    start)
        start
        ;;
    stop)
        stop
        ;;
    *)
        echo "Usage: $0 {start|stop}"
        exit 1
        ;;
esac

exit 0
