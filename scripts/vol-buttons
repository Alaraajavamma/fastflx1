#!/bin/bash

# Event file to monitor (make sure to use the correct event file)
EVENT_FILE="/dev/input/event1"

# Timeout threshold in seconds (4 seconds)
TIMEOUT_THRESHOLD=2

# Variables to track key presses
volume_up_count=0
volume_down_count=0
last_time=0

# Function to check if there are active calls using mmcli
is_call_active() {
  call_status=$(mmcli -m any --voice-list-calls 2>/dev/null)
  [[ "$call_status" != *"No calls were found"* ]]
}

# Function to handle commands based on equal up and down presses
handle_command() {
  # Check for active calls
  if is_call_active; then
    echo "Active call detected. Commands are disabled."
    return
  fi

  local count=$1
  local direction=$2

  if [[ "$count" -eq 1 && "$direction" == "up" ]]; then
    # One down + one up = screenshot
    cd /sys/class/leds/vibrator && echo 4000 > duration && echo 1 > activate && sleep 4

    SCREENSHOT_PATH="$(xdg-user-dir PICTURES)/Screenshot-$(date +%F-%T).png"
    gdbus call --session --dest org.gnome.Shell.Screenshot \
      --object-path /org/gnome/Shell/Screenshot \
      --method org.gnome.Shell.Screenshot.Screenshot \
      true false "$SCREENSHOT_PATH" &

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Screenshot saved to: $SCREENSHOT_PATH"
      command -v notify-send >/dev/null && notify-send "Screenshot Taken" "Saved to $SCREENSHOT_PATH"
    else
      echo "Failed to take screenshot."
    fi
  elif [[ "$count" -eq 1 && "$direction" == "down" ]]; then
    # One up + one down = picture
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate

    # Set up directory
    HOME_DIR="$HOME"
    PICTURES_DIR="$HOME_DIR/Pictures"
    mkdir -p "$PICTURES_DIR"

    # Get current date and time for filename
    DATETIME=$(date +"photo_%Y%m%d_%H%M%S")
    FILENAME="$PICTURES_DIR/$DATETIME.jpeg"

    # Command to take picture
    gst-launch-1.0 -e \
      droidcamsrc camera-device=0 mode=2 ! \
      videoconvert ! \
      videoflip video-direction=8 ! \
      jpegenc snapshot=true ! \
      filesink location="$FILENAME"

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Picture saved to: $FILENAME"
      command -v notify-send >/dev/null && notify-send "Picture Taken" "Saved to $FILENAME"
    else
      echo "Failed to take picture."
    fi
  elif [[ "$count" -eq 2 && "$direction" == "up" ]]; then
    # Two down + two up = open selector to kill biggest ram eaters
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
    excluded_apps="Isolated|system_server|phosh|phoc|calls|chatty|waydroid|systemd"

    # Get the top 5 RAM-consuming applications, excluding the defined apps
    apps=$(ps --no-headers -eo comm,%mem --sort=-%mem | grep -Ev "$excluded_apps" | head -n 3 | awk '{print $1}')
    apps_array=($apps)

    # Check if there are apps to show
    if [ ${#apps_array[@]} -eq 0 ]; then
        echo "No heavy RAM users found."
        return
    fi

    # Build the notify-send command with actions for each app
    notification_command="notify-send --expire-time=0 \"Kill a RAM-heavy app\" \"Swipe away to dismiss\""
    for i in "${!apps_array[@]}"; do
        notification_command+=" --action=\"${apps_array[$i]}\""
    done

    # Run the notification and capture the response
    response=$(eval $notification_command 2>&1)

    # Match response to the app and execute pkill
    for i in "${!apps_array[@]}"; do
        if [[ "$response" == "$i" ]]; then
            pkill -f "${apps_array[$i]}"
        fi
    done
  elif [[ "$count" -eq 2 && "$direction" == "down" ]]; then
    # Two up + two down = start android container shortcut
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    response=$(notify-send --icon="/home/furios/.git/fastflx1/files/fastflx1.svg" \
                           --expire-time=0 \
                           "Android container Actions" \
                           "Select an action for android container" \
                           --action="Start" \
                           --action="Stop" \
                           --action="Restart" \
                           2>&1)

    case "$response" in
        "0")
            pkexec systemctl start waydroid-container 
            waydroid session start &
            echo "Waydroid container started."
            ;;
        "1")
            waydroid session stop
            pkexec systemctl stop waydroid-container 
            echo "Waydroid shutdown."
            ;;
        "2")
            pkexec systemctl restart waydroid-container
            waydroid session start &
            echo "Waydroid rebooted."
            ;;
        *)
            echo "No valid action selected or dismissed."
            ;;
    esac
  fi
}

# Monitor the event file
while read -r event; do
  key_code=$(echo "$event" | grep -oP 'code \K[0-9]+')
  key_value=$(echo "$event" | grep -oP 'value \K[0-9]+')

  if [[ "$event" =~ "EV_KEY" && ( "$key_code" == "114" || "$key_code" == "115" ) && "$key_value" -eq 1 ]]; then
    current_time=$(date +%s)
    if (( current_time - last_time >= TIMEOUT_THRESHOLD )); then
      volume_up_count=0
      volume_down_count=0
    fi
    last_time=$current_time

    if [[ "$key_code" == "114" ]]; then
      volume_down_count=$((volume_down_count + 1))
      if [[ "$volume_down_count" -eq "$volume_up_count" && "$volume_down_count" -gt 0 && "$volume_down_count" -le 2 ]]; then
        handle_command "$volume_down_count" "down"
        volume_up_count=0
        volume_down_count=0
      fi
    elif [[ "$key_code" == "115" ]]; then
      volume_up_count=$((volume_up_count + 1))
      if [[ "$volume_up_count" -eq "$volume_down_count" && "$volume_up_count" -gt 0 && "$volume_up_count" -le 2 ]]; then
        handle_command "$volume_up_count" "up"
        volume_up_count=0
        volume_down_count=0
      fi
    fi
  fi
done < <(evtest "$EVENT_FILE")
