#!/bin/bash

# Event file to monitor (make sure to use the correct event file)
EVENT_FILE="/dev/input/event1"

# Timeout threshold in seconds (4 seconds)
TIMEOUT_THRESHOLD=2

# Variables to track key presses
volume_up_count=0
volume_down_count=0
last_time=0

# Function to handle commands based on equal up and down presses
handle_command() {
  local count=$1
  local direction=$2

  if [[ "$count" -eq 1 && "$direction" == "up" ]]; then
    # One down + one up = screenshot
    cd /sys/class/leds/vibrator && echo 500 > duration && echo 1 > activate &
    sleep 3

    SCREENSHOT_PATH="$(xdg-user-dir PICTURES)/Screenshot-$(date +%F-%T).png"
    gdbus call --session --dest org.gnome.Shell.Screenshot \
      --object-path /org/gnome/Shell/Screenshot \
      --method org.gnome.Shell.Screenshot.Screenshot \
      true false "$SCREENSHOT_PATH" &

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Screenshot saved to: $SCREENSHOT_PATH"
      command -v notify-send >/dev/null && notify-send "Screenshot Taken" "Saved to $SCREENSHOT_PATH"
    else
      echo "Failed to take screenshot."
    fi
  elif [[ "$count" -eq 1 && "$direction" == "down" ]]; then
    # One up + one down = picture
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate

    # Set up directory
    HOME_DIR="$HOME"
    PICTURES_DIR="$HOME_DIR/Pictures"
    mkdir -p "$PICTURES_DIR"

    # Get current date and time for filename
    DATETIME=$(date +"photo_%Y%m%d_%H%M%S")
    FILENAME="$PICTURES_DIR/$DATETIME.jpeg"

    # Command to take picture
    gst-launch-1.0 -e \
      droidcamsrc camera-device=0 mode=2 ! \
      videoconvert ! \
      videoflip video-direction=8 ! \
      jpegenc snapshot=true ! \
      filesink location="$FILENAME"

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Picture saved to: $FILENAME"
      command -v notify-send >/dev/null && notify-send "Picture Taken" "Saved to $FILENAME"
    else
      echo "Failed to take picture."
    fi
  elif [[ "$count" -eq 2 && "$direction" == "up" ]]; then
    # Two down + two up = open selector to kill biggest ram eaters
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
    # Define the list of apps to exclude
excluded_apps="Isolated|system_server|phosh|phoc|calls|chatty|waydroid|systemd"

# Get the top 5 RAM-consuming applications, excluding the defined apps
apps=$(ps --no-headers -eo comm,%mem --sort=-%mem | grep -Ev "$excluded_apps" | head -n 3 | awk '{print $1}')
apps_array=($apps)

# Check if there are apps to show
if [ ${#apps_array[@]} -eq 0 ]; then
    echo lol
fi

# Build the notify-send command with actions for each app
notification_command="notify-send --expire-time=0 \"Kill a RAM-heavy app\" \"Swipe away to dismiss\""
for i in "${!apps_array[@]}"; do
    notification_command+=" --action=\"${apps_array[$i]}\""
done

# Run the notification and capture the response
response=$(eval $notification_command 2>&1)

# Match response to the app and execute pkill
for i in "${!apps_array[@]}"; do
    if [[ "$response" == "$i" ]]; then
        pkill -f "${apps_array[$i]}"
    fi
done
    
  elif [[ "$count" -eq 2 && "$direction" == "down" ]]; then
    # Two up + two down = start android container shortcut
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    # Send the notification with selectable actions
response=$(notify-send --icon="/home/furios/.git/fastflx1/files/fastflx1.svg" \
                       --expire-time=0 \
                       "Android container Actions" \
                       "Select an action for android container" \
                       --action="Start" \
                       --action="Stop" \
                       --action="Restart" \
                       2>&1)

# Check which action was selected
case "$response" in
    "0")
        # Start Waydroid container
        pkexec waydroid container start
        echo "Waydroid container stopped."
        ;;
    "1")
        # Stop Waydroid
        pkexec waydroid container stop
        echo "Waydroid shutdown."
        ;;
    "2")
        # Reboot Waydroid
        pkexec waydroid container restart
        echo "Waydroid rebooted."
        ;;
    *)
        # Handle dismissal or invalid selection
        echo "No valid action selected or dismissed"
        ;;
esac

    
  fi
}

# Monitor the event file
while read -r event; do
  # Extract the key code and value from evtest output
  key_code=$(echo "$event" | grep -oP 'code \K[0-9]+')
  key_value=$(echo "$event" | grep -oP 'value \K[0-9]+')

  # Only care about EV_KEY events for volume up (115) or volume down (114)
  if [[ "$event" =~ "EV_KEY" && ( "$key_code" == "114" || "$key_code" == "115" ) && "$key_value" -eq 1 ]]; then
    # Get the current time in seconds
    current_time=$(date +%s)

    # Check if timeout has occurred and reset counters if necessary
    if (( current_time - last_time >= TIMEOUT_THRESHOLD )); then
      echo "Timeout occurred. Resetting counters."
      volume_up_count=0
      volume_down_count=0
    fi

    # Update the time of the last key press
    last_time=$current_time

    # Handle key press logic
    if [[ "$key_code" == "114" ]]; then  # Volume Down
      volume_down_count=$((volume_down_count + 1))

      if [[ "$volume_down_count" -eq "$volume_up_count" && "$volume_down_count" -gt 0 && "$volume_down_count" -le 2 ]]; then
        handle_command "$volume_down_count" "down"
        volume_up_count=0
        volume_down_count=0
      fi

    elif [[ "$key_code" == "115" ]]; then  # Volume Up
      volume_up_count=$((volume_up_count + 1))

      if [[ "$volume_up_count" -eq "$volume_down_count" && "$volume_up_count" -gt 0 && "$volume_up_count" -le 2 ]]; then
        handle_command "$volume_up_count" "up"
        volume_up_count=0
        volume_down_count=0
      fi
    fi
  fi
done < <(evtest "$EVENT_FILE")

