#!/bin/bash

# Event file to monitor (make sure to use the correct event file)
EVENT_FILE="/dev/input/event1"

# Timeout threshold in seconds (2 seconds)
TIMEOUT_THRESHOLD=2

# Variables to track key presses
volume_up_count=0
volume_down_count=0
last_time=0

# Function to handle commands based on equal up and down presses
handle_command() {
  local count=$1
  local direction=$2

  if [[ "$count" -eq 1 && "$direction" == "up" ]]; then
    # One down + one up = screenshot
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    sleep 3

    SCREENSHOT_PATH="$(xdg-user-dir PICTURES)/Screenshot-$(date +%F-%T).png"
    gdbus call --session --dest org.gnome.Shell.Screenshot \
      --object-path /org/gnome/Shell/Screenshot \
      --method org.gnome.Shell.Screenshot.Screenshot \
      true false "$SCREENSHOT_PATH" &

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Screenshot saved to: $SCREENSHOT_PATH"
      command -v notify-send >/dev/null && notify-send "Screenshot Taken" "Saved to $SCREENSHOT_PATH"
    else
      echo "Failed to take screenshot."
    fi
  elif [[ "$count" -eq 1 && "$direction" == "down" ]]; then
    # One up + one down = picture
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate

    # Set up directory
    HOME_DIR="$HOME"
    PICTURES_DIR="$HOME_DIR/Pictures"
    mkdir -p "$PICTURES_DIR"

    # Get current date and time for filename
    DATETIME=$(date +"photo_%Y%m%d_%H%M%S")
    FILENAME="$PICTURES_DIR/$DATETIME.jpeg"

    # Command to take picture
    gst-launch-1.0 -e \
      droidcamsrc camera-device=0 mode=2 ! \
      videoconvert ! \
      videoflip video-direction=8 ! \
      jpegenc snapshot=true ! \
      filesink location="$FILENAME"

    # Notify user
    if [ $? -eq 0 ]; then
      echo "Picture saved to: $FILENAME"
      command -v notify-send >/dev/null && notify-send "Picture Taken" "Saved to $FILENAME"
    else
      echo "Failed to take picture."
    fi
  elif [[ "$count" -eq 2 && "$direction" == "up" ]]; then
    # Two down + two up = wip
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
  elif [[ "$count" -eq 2 && "$direction" == "down" ]]; then
    # Two up + two down = wip
    cd /sys/class/leds/vibrator && echo 200 > duration && echo 1 > activate
    cd /sys/class/leds/vibrator && echo 100 > duration && echo 1 > activate
  fi
}

# Monitor the event file
while read -r event; do
  # Extract the key code and value from evtest output
  key_code=$(echo "$event" | grep -oP 'code \K[0-9]+')
  key_value=$(echo "$event" | grep -oP 'value \K[0-9]+')

  # Only care about EV_KEY events for volume up (115) or volume down (114)
  if [[ "$event" =~ "EV_KEY" && ( "$key_code" == "114" || "$key_code" == "115" ) && "$key_value" -eq 1 ]]; then
    # Get the current time in seconds
    current_time=$(date +%s)

    # Check if timeout has occurred and reset counters if necessary
    if (( current_time - last_time >= TIMEOUT_THRESHOLD )); then
      echo "Timeout occurred. Resetting counters."
      volume_up_count=0
      volume_down_count=0
    fi

    # Update the time of the last key press
    last_time=$current_time

    # Handle key press logic
    if [[ "$key_code" == "114" ]]; then  # Volume Down
      volume_down_count=$((volume_down_count + 1))

      if [[ "$volume_down_count" -eq "$volume_up_count" && "$volume_down_count" -gt 0 && "$volume_down_count" -le 2 ]]; then
        handle_command "$volume_down_count" "down"
        volume_up_count=0
        volume_down_count=0
      fi

    elif [[ "$key_code" == "115" ]]; then  # Volume Up
      volume_up_count=$((volume_up_count + 1))

      if [[ "$volume_up_count" -eq "$volume_down_count" && "$volume_up_count" -gt 0 && "$volume_up_count" -le 2 ]]; then
        handle_command "$volume_up_count" "up"
        volume_up_count=0
        volume_down_count=0
      fi
    fi
  fi
done < <(evtest "$EVENT_FILE")

